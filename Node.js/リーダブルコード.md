商品リンク
https://amzn.to/2xF83gb


# 目次
1. 理解しやすいコード
2. 名前に情報を詰め込む
3. 誤解されない名前
4. 美しさ
5. コメントすべきことを知る
6. コメントは正確で簡潔に
7. 制御フローを読みやすくする
8. 巨大な式を分割する
9. 変数と読みやすさ
10. 無関係の怪問題を抽出する
11. 一度に１つのことを
12. コードに思いを込める
13. 短いコードを書く
14. テストと読みやすさ
15. 「分/時間カウンタ」を設計実装する
16. 付録

# 理解しやすいコード
- 🔑コードは理解しやすくなければいけない
- 🔑コードは他人が最短で理解できように書かなければいけない
- コードは短い方がいい。だけど「理解するまでにかかる時間」を短くする方が大切

# 名前に情報を詰め込む
- 🔑名前に情報を詰め込む
- テーマ
  1. 明確な単語を選ぶ
  2. 汎用的な名前を避ける
  3. 抽象的な名前よりも具体的な名前を使う
  4. 接尾辞や接頭辞を使って情報を追加する
  5. 名前の長さを決める
  6. 名前のフォーマットで情報を伝える
- 明確な単語を選ぶ
  - getはあまり明確な単語ではない
    - GetPage(url)ならば、DownloadPage()の方が明確
  - Size()では何を返すメソッドだか分からない
    - Height(), NumNodes(), MemoryBytes()など
  - Stop()より、動作に合わせて明確な名前の方が良い
    - 取り消しがつかない思い操作ならKill()
    - 後からResume()できるなら、Pause()
- シソーラス(類語辞典)を活用してみよう
  - send : deliver, dispatch, announce
  - find : search, extract, locate
  - start : launch, create, begin, open
- 🔑気取った言い回しよりも明確で正確な方がいい
- tmpやretvalなどの汎用的な名前を避ける
  - retvalには「これは戻り値です」以外の情報はない
    - 2乗の合計を表すなら、sum_squares
    - 💬retvalという名前には情報がない。変数の値を表すような名前を使おう
  - 💬tmpという名前は、生存期間が短くて、一時位的な保管が最も大切な変数にだけ使おう
- ループイテレータ
  - i・j・k・iterなどの名前は、インデックスやループイテレータでよく使われている
  - イテレータが複数ある場合には、インデックスにもっと明確な名前をつける
    - i・j・kではなく、説明的な名前(club_i・member_i・users_i)にする
- uuutmp・it・retvalのような汎用的な名前を使う時は、それ相応の理由を用意しよう
- 値の単位
  - 単位のない仮引数と、単位を追加したよりよいバージョンの仮引数
    - delay : delay_secs
    - size : size_mb
    - limit : max_kbps
    - angle : degrees_cw
- 変数の意味を間違ってしまった時にバグになりそうなところにだけ重要な属性を追加する
- 名前の長さを決める
  - 長い名前を避ける理由はいくつもあるが、「入力しにくい」というのは理由にならない
  - 頭文字と省略系は、stringを「str」とすれば理解できる様にチームメイトが理解できるだろうか
  - 単語を除いても意味が損なわれないものはその不要な単語を投げ捨てる
- 名前のフォーマットで情報を伝える
  - アンダースコア・ダッシュ・大文字を使って名前に情報を詰め込むことができる
  - 様々なフォーマット規約
    - CamelCase(キャメルケース): 小文字をアンダースコアで区切ったもの
    - コンストラクタ(newで呼び出される関数)は大文字で始める
    - 通常の関数は小文字で始める
## まとめ
- 明確な単語を選ぶ
  - 例えば。Getではなく、状況に応じてFetchやDownloadなどを使う
- tmpやretvalなどの汎用的な名前を避ける
  - ただし、明確な理由があれば話は別
- 具体的な名前を使って、物事を詳細に説明する
  - ServerCanStart()よりも、CanListenOnPort()の方が明確
- 変数名に大切な情報を追加する
  - ミリ秒を表す変数名には後ろに_msをつける。これからエスケープが必要な変数には、前にraw_をつける
- スコープの大きな変数には長い名前をつける
  - スコープが数画面におよぶ変数名に1~2文字の短い暗号名た名前をつけてはいけない
  - 短い名前はスコープが数行の変数につけるべきだ
- 大文字やアンダースコアなどに意味を含める
  - 例えば、クラスのメンバー変数にアンダースコアをつけて、ローカル変数と区別する

# 誤解されない名前
- 🔑名前が「他の意味と間違えられることはないだろうか？」と何度も自問自答する
- filter()
  - 「選択」するのであればSelect(), 「除外」するのであればexclued()
- 限界値を含める時はminとmaxを使う
  - limitという名前では「未満」なのか「以下」なのかが分からず曖昧になる
  - 💬限界値を明確にするには、名前の前にmax_やmin_をつけよう
- 範囲を指定する時はfirstとlastを使う
- 複合/排他的範囲にはbeginとendを使う
- ブール値の名前
  - ブール値を変数名は、値にis・has・can・shouldなどをつけて分かりやすくする
    - SpaceLeft()がもしブール値を返す場合はHasSpaceLedt()としたほうがよい
  - 変数名を否定的にするのは避けた方がいい
    - disable_ssl = false; より use_ssl = true; の方が短くて、声に出して読みやすい
- ユーザーの期待に合わせる
  - ユーザーが先入観を持っているために誤解を招いてしまうことがあるため、諦めて誤解されない名前にする
- まとめ
  - あなたのコードを読んでいる人が、あなたの意図を正しく理解できるようにする

# 美しさ
- 著者たちが使っている3つの原則
  - 読み手が慣れているパターンと一貫性のあるレイアウトを使う
  - 似ているコードは似ているように見せる
  - 関連するコードをまとめてブロックにする
- 考えてみれば、プログラミングの時間のほとんどはコードを読む時間なのだッ！
- 一貫性のある簡潔な改行位置
  - 会社やプロジェクト単位などで、コーディング標準を守る
- メソッドを使った整列
- 縦の線をまっすぐにする
  - メソッドの引数を空白を使って整列する
  - 似た様なコードの場合、整列していることでタイプミスにも気付きやすくなる
- 一貫性の意味のある並び
  - 最重要なものから重要度順に並べる
  - アルファベット順に並べる
- 宣言をブロックにまとめる
  - 人間の脳はグループや階層を1つの単位として考えるので、コードを早く理解するには単位を作る
    - 全てのメソッドをトンリ的なグループに分ける
- コードを段落に分割する
  - 文章は複数の段落に分割されており、コードも同じ理由で分けるべき
    - 似ている考えをグループにまとめて、他の考えと分ける
    - 視覚的な「踏み石」を提供でき、ページの中で自分の場所を見失わない様にする
    - 段落単位で移動できるようになる
- 🔑一貫性のあるスタイルは「正しい」スタイルよりも大切だ
## まとめ
- 複数のコードブロックで同じ様なことをしていたら、シルエットも同じ様なものにする
- コードの「列」を整理すれば、概要が把握しやすくなる
- ある場所でA・B・Cのように並んでいたものを、他の場所でB・C・Aのように並べてはいけない。意味のある順番を選んで常にその順番を守る
- 空行を使って大きなブロックを論理的な段落にわける

# コメントすべきことを知る
- 🔑コメントの目的は書き手の意図を読み手に知らせることである
- テーマ
  - コメントするべきでは「ない」ことを知る
  - コードを書いているときの自分の考えを記録する
  - 読み手の立場になって何が必要になるかを考える
- 🔑コードからすぐにわかることをコメントに書かない
- ひどい名前はコメントをつけずに名前を変える
  - 繰り返し使われる関数名などは、優れたコメントより名前の方が大切
  - 通常は「補助的なコメント」（コードの読みにくさを補うコメント）が必要になることはない
    - 「優れたコード　＞ ひどいコード＋優れたコメント」
  - 自分の考えを記録する
  - コードの血管にコメントをつける
    - コードは絶えず進化するので、その過程で欠陥を生む運命なので、欠陥を文書化することを恥ずかしがらなくていい
    - 記法
      - TODO  : あとで手をつける
      - FIXME : 既知の不具合があるコード
      - HACK  : あまり綺麗じゃない解決策
      - XXX   : 危険！大きな問題がある
  - 定数にコメントをつける
    - 定数が何をするのか、なぜその値を持っているのかという「背景」についてを記録する
- ライダーズブロックを乗り越える
  - ライダーズブロック: 行き詰まってしまって、文章がかけないこと
  - コメントを書く手順は、3つの簡単な手順に分解できる
    1. 頭の中にあるコメントをとにかく書き出す
    2. コメントを読んで（どちらかと言えば）改善が必要なものを見つける
    3. 改善する
      - コメントを書く様になれば、次第に手順1の品質がよくなっていく
## まとめ
- コメントすべきでは「ない」こと
  - コードからすぐに抽出できること
  - ひどいコードを補う「補助的なコメント」はコメントを書くのではなくコードを修正する
- 記録すべき自分の考え
  - なぜコードが他のやり方ではなくこうなっているのか(「監督コメンタリー」)
  - コードの欠陥をTOFO:やXXX:などの気泡を使って示す
  - 定数の値にまつわる「背景」
- 読み手の立場になって考える
  - コードを読んだ人が「えっ？」と思うところを予測してコメントをつける
  - 平均的な良い手が驚く様な動作は文書化しておく
  - ファイルやクラスには全体像のコメントを書く
  - 読み手が細部に捕われないように、コードブロックにコメントをつけて概要をまとめる

# コメントは性格で簡潔に
- 🔑コメントは領域に対する情報の比率が高くなければいけない
- コメントは簡潔にしておく
- あいまいな代名詞を避ける
- コードの意図を書く
- 「名前付き引数」コメント
  - 値の前にコメントを置く
- 情報密度の高い言葉を使う
## まとめ
- 複数のものを指す可能性がある「それ」や「これ」などの代名詞を避ける
- 関数の動作はできるだけ正確に説明する
- コメントに含める入出力の逸例を慎重に選ぶ
- コードの意図は、詳細レベルではなく、高レベルで記述する
- よくわからない引数にはインラインコメントを使う(ex: Function(/* arg = */...))
- 多くの意味が詰め込まれた言葉や表現を使って、コメントを簡潔に保つ

# さんフローを読みやすくする
- 🔑条件やループなどの制御フローはできるだけ「自然」にする。コードの読み手が立ち止まったり読み返したりしないように書く
- 条件式の引数の並び順
  - 比較式の読みやすい並び
    - 左側：変化する「調査対象」
    - 右側：あまり変化しない「比較対象」
- if/else ブロックの並び順
  - 条件は否定系よりも肯定を使う
  - 単純な条件を先に書く。ifとelseが同じ画面に表示されるのでみやすい
  - 関心を引く条件や目立つ条件を先に書く
- 三項演算子
  - 条件 ? a = b
    - if(条件){a}else{b}
  - 🔑行数を短くするよりも、他人が理解するのにかかる時間を短くする
  - 💬基本的にはif/elseを使おう。三項演算子はそれによって簡潔になる時にだけ使おう
- do/whileループを避けよう
  - do {式} while (条件)
  - whileループで書き直すことが多い
- 関数から早く返す
  - 📣複数のreturn文を使ってはいけないと思っている人がいる。アホくさ
  - ガード節
    - if(str == null || substr == null) return false;
  - クリーンアップコード
    - ガード節より洗練された言語ごとの形
- 悪名高きgoto
  - C言語以外ではgotoはほとんど必要ない
- ネストを浅くする
- ネストが増える仕組み
  - 🔑変更するときにはコードを新鮮な目で見る。一歩下がって全体を見る
- 早めに返してネストを削除する
  - ネストを削除するには「失敗」ケースをできるだけ早めに関数から返せばいい
- ループ内部のネストを削除する
  - ループ内部で行うにはcontinueを使う（ガード節）
- コードの構成要素
  - スレッド:               どのコードがいつ実行されるのかよくわからない
  - シグナル/割り込みハンドラ: 他のコードが実行される可能性がある
  - 例外:                   いろんな関数呼び出しが終了しようとする
  - 関数ポインタと無名関数:   コンパイル時に判断できないので、どのコードが実行されるのかわからない
  - 仮想メソッド:           objectvirtualMethod()は道のサブクラスのコードを呼び出す可能性がある
## まとめ
- 比較を書く時には変化する値を左に、より安定した値を右に配置する
- if/else文のブロックは適切に並び替える
  - 肯定・単純・目立つものは先
- 三項演算子(? :)、do/while、gotoはコードが読みにくくなることが多い
- ネストはコードを追うのに集中力を必要とする
  - ネストを減らすにはガード節を活用できる

# 巨大な式を分割する
- 🔑巨大な式は飲み込みやすい大きさに分割する
  - 人間は一度に３〜４の「もの」しか考えられないそうだ
- 説明変数
- 要約変数
- ド・モルガンの法則
  - notを分配してand/orを反転する
    - not(a or b or c)  == (not a)and(not b)and(not c)
    - not(a and b and c) == (not a)or(not b)or(not c)
- 短絡評価の悪用
  - 🔑「頭がいい」コードに気を付ける。あとで他人がコードを読む時にわかりにくくなる
- 複雑なロジックと格闘
  - より優雅な手法を見つける
- 巨大な文を分割する
  - 同じ式は要約変数として関数の最上位に抽出
  - 同じものが何度も登場する値は短い変数に
    - タイプミスを減らす
    - 横幅が縮まるのでコードが読みやすくなる
    - クラス名を変更することになれば、一箇所を変更すればよい
- 式を簡潔にするもう１つの創造的な方法
## まとめ
- 巨大な式は分割する
  - 説明変数のメリット
    - 巨大な式を分割できる
    - 簡潔な名前で式を説明することで、コードを文書化できる
    - コードの主要な「概念」を読み手が認識しやすくなる


# 変数と読みやすさ
- テーマ
1. 変数が多いと変数を追跡するのが難しくなる
2. 変数のスコープが大きいとスコープを把握する時間が長くなる
3. 変数が頻繁に更新されると現在の値を把握するのが難しくなる

- 変数を削除する
  - 役に立たない一時変数
  - 中間結果を削除する
  - 制御フロー変数を削除する
    - breakが使えないようなネストが何段階もあるループの場合
      - コードを新しい関数に移動する
- 変数のスコープを縮める
  - 🔑変数のことが見えるコード行数をできるだけ減らす
  - メンバ変数
    - クラスの中にある変数
    - クラスの中で「ミニグローバル」になっているものは極力減らすべき
    - メソッドをできるだけstaticにすること
    - 大きなクラスを小さなクラスに分割
      - 相互に参照し合うようなら意味がない
  - javascriptの「プライベート」変数を作る
    - グローバル変数だったものを、クロージャで包む
      - クロージャ: 関数とその関数が定義された状態をセットにした特殊なオブジェクト
        - 変数に関数を格納すると「その関数定義自体」と共に「その環境」が格納されることを利用する、関数を状態ごと保持したオブジェクト
  - javascriptのグローバルスコープ
    - varをつけないで変数定義をするとグローバルスコープに入ってしまう
  - Pythonとjavscriptのネストしないスコープ
  - 変数は一度だけ書き込む
    - 🔑変数を操作する場所が増えると、現在地の判断がむずかしくなる
## まとめ
- 邪魔な変数を削除する
  - 結果をすぐに使って「中間結果」の変数を削除する例
- 変数のスコープをできるだけ小さくする
  - 変数を数行のコードからしか見えない位置に移動する
- 一度だけ書き込む変数を使う
  - 変数に一度だけ値を設定すれば、コードが理解しやすくなる

# 無関係の怪問題を抽出する
- 無関係の怪問題を積極的に見つけて抽出すること
  - 著者の考え
    - 関数やコードブロックをみて「このコードの高レベルの目標は何か？」と自問する
    - コードの各行に対して「高レベルの目標に直接的に効果があるのか？あるいは、無関係の下位問題を解決しているのか？」と自問する
    - 無関係の下位問題を解決しているコードが相当量あれば、それらを抽出して別の関数にする
- 思いも寄らない恩恵
  - 呼び出し側のコードが簡潔になる
  - コードが独立していれば関数側の改善が楽になる
    - 関数は、小さく独立していれば、機能追加・読みやすさの向上、エッジケースの処理などが楽になる
- やりすぎ
  - 小さな関数を作りすぎると、ありこちに飛び回る実行パスを追いかけるため、逆に読みにくくなる
  - 新しい関数をコードに追加すると、ごくわずかに（確実に）読みにくさのコストが発生する
## まとめ
- プロジェクト固有のコードから汎用コードを分離すること
- 一般的な問題を解決するライブラリやヘルパー関数を作っていけば、プログラム固有の小さな書くだけ残る


# 一度に1つのことを
- 🔑コードは1つずつタスクを行うようにしなければいけない
- デフラグ（最適化）
- 手順
  1. コードが多なっているタスク路全て列挙する
  2. オブジェクトが妥当かどうか確認する
  3. ツリーの全てのオードをインてレートする
  4. タスクをできるだけ異なる関数に分割し、少なくとも異なる領域に分割する

- タスクは小さくできる
- オブジェクトから値を抽出する

# コードに思いを込める
- アルバート・アインシュタイン
  - おばあちゃんがわかるように説明できなければ、本当に理解したとは言えない
- コードを明確にする手順
  1. コードの動作を簡単な言葉で同僚にもわかるように説明する
  2. その説明のなかで使っているキーワードやフレーズに注目する
  3. その説明に合わせてコードを書く
- 解決策を言葉で説明する
  - もう一度、これからやろうとしていることを簡単な言葉で説明しよう
- 手法を再起的に適用する
## まとめ
- 「簡単な言葉で説明する」手法
  - 又の名を「ラバーダッキング」
  - 問題や設計をうまく言葉で説明できないのであれば、何かを見落としているか詳細が明確になっていない
  - プログラムを古土場にすることで明確な形になる

# 短いコードを書く
- 🔑最も読みやすいコードは、何も書かれていないコードだ
- その昨日の実装について悩まないで、きっと必要ないから
  - 欠かせない機能を多く見積もり、多くの機能が完成しないか、全く使われないでいる
- コードを小さく保つ
  - プロジェクトが成長しても、コードをできるだけ小さく軽量に維持するしかない
    - 汎用的な「ユーティリティー」コードを使って、重複コードを削除する
    - 未使用のコードや無用の機能を削除する
      - コードを削除すれば、そこに費やした時間を無駄にすることになる。そんなのどうでもいいんだよ！
    - プロジェクトをサブプロジェクトに分割する
    - コードの「重量」を意識する。軽量で機敏にしておく
- 身近なライブラリに親しむ
  - 既存ライブラリで問が解決できることを知らないプラグラマが多い
  - 提案
    - 標準ライブラリの全ての関数・モジュール・型の名前を15分かけて読んでみよう
  - ライブラリの再利用はなぜいいことなのか
    - 平均的なソフトウェアエンジニアが1日に書く「出荷用のコード」は10行
      - 成熟したライブラリには生き残っているだけの勝ちがある
      - ライブラリの裏側：膨大な設計、デバッグ、修正、文章、最適化、テストが存在する
- 400や500が含まれたアクセスログを探すには
  - cat access.log| aws '{print $5 " " $7}'|egrep "[45]..$ ¥
  - |sort |uniq -c |sort -nr
  - #<カウント> <パス> <HTTPレスポンスコード>
## まとめ
- ヨーダ
  - 冒険。興奮。ジェダイはそんなものは求めておらん
- できるだけコードを書かないこと、新しいコードはテストや文書、保守が必要になる
  1. 不必要な機能をプロダクトから削除する。過剰な機能は持たせない
  2. 最も簡単に問題を解決できるような要求を考える
  3. 定期的に全てのAPIを読んで、標準ライブラリに慣れ親しんでおく

# テストと読みやすさ
- テストを読みやすくて保守しやすいものにする
- 🔑他のプログラムが安心してテストの追加や変更ができるように、テストコードを読みやすくする
- テストコードが大きくて恐ろしいものだとしたら・・・
  - 本物のコードを修正するおを恐る
  - 新しいコードを書いた時にテストを追加しなくなる
- テストを読みやすくする
  - 一般的な設計原則
    - 大切ではない詳細はユーザーから隠し、大切な詳細は目立つようにする
  - エラーメッセージを読みやすくする
    - assert()メソッドを活用してみる
    - 手作りエラーメッセージ(手作りアサート)を用意する
- テストの適切な入力を選択
  - 🔑コードを完全にテストする最も単純な入力値の組み合わせを選択しなければいけない
  - 入力値を単純化する
    - 🔑テストには最も綺麗で単純な値を選ぶ
  - 大量破壊テスト：大量の入力値を使う
  - １つの機能に複数のテスト
    - 複数のテストで別々の方向からバグを見つけだすようにする
    - 失敗したテストによってその場所がわかる
- テストの機能に名前をつける
  - 例えば
    - テストコード名： Test_<テスト対象の関数名>
    - テストコード名： Test_<テスト対象の関数名>_<状況>
      - pythonのunittestモジュールでは、メソッド名はtestから始めなければいけない
  - テスト関数の名前はコメントだと思えばいい
  - テストコードのヘルパー関数は、アサートを使っているかどうかで名前を統一するなど（Check...から始める）
- テストに優しい開発
  - あとでテストを書くつもりでコードを書くと「テストしやすいコードを設計するようになるのだ！」
    - このようにコードを書いていけば、いいコードが描けるようになる！
  - クラスやメソッドを分割するということは、疎結合になりテストしやすいから
- やりすぎ
  - テストのために本物のコードの読みやすさを犠牲にする
  - テストのがバレッジを100％にしないと気が済まない
  - テストがプロダクト開発の邪魔になる
## まとめ
- テストコードも読みやすさが大切
  - テストが読み易ければ、テストが書きやすくなり、みんなテストを追加しやすくなる
- テストの改善点
  - テストのトップレベルはできるだけ簡潔にする。入出力のテストはコード1行で記述できるといい
  - テストが失敗したらバグの発見や修正がしやすいようなエラーメッセージを表示する
  - テストに有効な最も単純な入力値を使う
  - テスト関数に説明的な名前をつけて、何をテストしているのかを明らかにする
- 新しいテストの追加や修正を簡単にすることが大切

#総まとめ
- 自然に読みやすいコードを描ける様になるために3ステップ
  1. 実際にやる
  2. 当たり前にする
  3. コードで伝える
- 実際にやる
  - 実際にやるとぶつかること
  - 他人に読んでもらう
- 当たり前にする
  - 既存のコードを読みやすくする前にやること
  - 続けることが大事
- コードで伝える
  - 読みやすいコードがもっと当たり前であり続けるために
 
